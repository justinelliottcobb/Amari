//! Product measures and Fubini's theorem
//!
//! This module provides product σ-algebras, product measures, and Fubini's theorem
//! for integrating over product spaces.
//!
//! # Core Concepts
//!
//! ## Product σ-algebra
//!
//! Given σ-algebras Σ₁ on X₁ and Σ₂ on X₂, the product σ-algebra Σ₁ ⊗ Σ₂ on X₁ × X₂
//! is the smallest σ-algebra containing all rectangles A₁ × A₂ where A₁ ∈ Σ₁ and A₂ ∈ Σ₂.
//!
//! ## Product Measure
//!
//! Given measures μ on (X₁, Σ₁) and ν on (X₂, Σ₂), the product measure μ ⊗ ν on
//! (X₁ × X₂, Σ₁ ⊗ Σ₂) is uniquely determined by:
//!
//! (μ ⊗ ν)(A₁ × A₂) = μ(A₁) · ν(A₂)
//!
//! for all A₁ ∈ Σ₁ and A₂ ∈ Σ₂.
//!
//! ## Fubini's Theorem
//!
//! Let (X₁, Σ₁, μ) and (X₂, Σ₂, ν) be σ-finite measure spaces.
//! For an integrable function f: X₁ × X₂ → ℝ:
//!
//! ∫∫ f d(μ ⊗ ν) = ∫ (∫ f(x₁, x₂) dν(x₂)) dμ(x₁) = ∫ (∫ f(x₁, x₂) dμ(x₁)) dν(x₂)
//!
//! # Examples
//!
//! ```ignore
//! use amari_measure::{ProductMeasure, LebesgueMeasure, SigmaFinite, Unsigned, Complete};
//!
//! // Product of two Lebesgue measures: ℝ² = ℝ × ℝ
//! let mu = LebesgueMeasure::new(1);
//! let nu = LebesgueMeasure::new(1);
//! let product: ProductMeasure<_, _, _, _, SigmaFinite, Unsigned, Complete> =
//!     ProductMeasure::new(mu, nu);
//!
//! // This gives Lebesgue measure on ℝ²
//! ```

use crate::measure::Measure;
use crate::phantom::*;
use crate::sigma_algebra::SigmaAlgebra;
use core::marker::PhantomData;

/// Product σ-algebra Σ₁ ⊗ Σ₂
///
/// The product σ-algebra on X₁ × X₂ is the smallest σ-algebra containing
/// all measurable rectangles A₁ × A₂ where A₁ ∈ Σ₁ and A₂ ∈ Σ₂.
///
/// # Type Parameters
///
/// - `Σ₁`: First σ-algebra
/// - `Σ₂`: Second σ-algebra
///
/// # Mathematical Properties
///
/// - Generated by measurable rectangles: {A₁ × A₂ : A₁ ∈ Σ₁, A₂ ∈ Σ₂}
/// - Strictly smaller than the power set of X₁ × X₂ (in general)
/// - Sections A_{x₁} = {x₂ : (x₁, x₂) ∈ A} are Σ₂-measurable for each A ∈ Σ₁ ⊗ Σ₂
///
/// # Examples
///
/// ```
/// use amari_measure::{ProductSigma, BorelSigma};
///
/// // Product of Borel σ-algebras: ℝ² = ℝ × ℝ
/// let borel_r1 = BorelSigma::new(1);
/// let borel_r2 = BorelSigma::new(1);
/// let borel_r2_product = ProductSigma::new(borel_r1, borel_r2);
/// ```
#[derive(Clone)]
pub struct ProductSigma<Σ1, Σ2>
where
    Σ1: SigmaAlgebra,
    Σ2: SigmaAlgebra,
{
    /// First σ-algebra
    sigma1: Σ1,

    /// Second σ-algebra
    sigma2: Σ2,
}

impl<Σ1, Σ2> ProductSigma<Σ1, Σ2>
where
    Σ1: SigmaAlgebra,
    Σ2: SigmaAlgebra,
{
    /// Create a new product σ-algebra
    ///
    /// # Arguments
    ///
    /// * `sigma1` - First σ-algebra
    /// * `sigma2` - Second σ-algebra
    ///
    /// # Examples
    ///
    /// ```
    /// use amari_measure::{ProductSigma, LebesgueSigma};
    ///
    /// let lebesgue1 = LebesgueSigma::new(2);
    /// let lebesgue2 = LebesgueSigma::new(3);
    /// let product = ProductSigma::new(lebesgue1, lebesgue2);
    /// // This gives the Lebesgue σ-algebra on ℝ⁵
    /// ```
    pub fn new(sigma1: Σ1, sigma2: Σ2) -> Self {
        Self { sigma1, sigma2 }
    }

    /// Get a reference to the first σ-algebra
    pub fn first(&self) -> &Σ1 {
        &self.sigma1
    }

    /// Get a reference to the second σ-algebra
    pub fn second(&self) -> &Σ2 {
        &self.sigma2
    }
}

/// Product measure μ ⊗ ν
///
/// Given measures μ on (X₁, Σ₁) and ν on (X₂, Σ₂), the product measure
/// is defined on the product σ-algebra Σ₁ ⊗ Σ₂ by:
///
/// (μ ⊗ ν)(A₁ × A₂) = μ(A₁) · ν(A₂)
///
/// for measurable rectangles A₁ × A₂.
///
/// # Type Parameters
///
/// - `Σ₁`, `Σ₂`: σ-algebra types
/// - `M₁`, `M₂`: Measure types
/// - `F₁`, `F₂`: Finiteness properties
/// - `S₁`, `S₂`: Sign properties
/// - `C₁`, `C₂`: Completeness properties
///
/// # Mathematical Foundation
///
/// ## Construction
///
/// The product measure is constructed via the Carathéodory extension theorem:
/// 1. Define on rectangles: (μ ⊗ ν)(A₁ × A₂) = μ(A₁) · ν(A₂)
/// 2. Extend to the σ-algebra generated by rectangles
/// 3. Uniqueness follows from σ-finiteness
///
/// ## Properties
///
/// - **σ-finiteness**: If μ and ν are σ-finite, so is μ ⊗ ν
/// - **Marginals**: Projecting onto X₁ or X₂ recovers μ or ν
/// - **Iteration**: Integration can be computed via iterated integrals (Fubini)
///
/// # Examples
///
/// ```ignore
/// use amari_measure::{ProductMeasure, LebesgueMeasure};
///
/// // Lebesgue measure on ℝ²
/// let mu = LebesgueMeasure::new(1);
/// let nu = LebesgueMeasure::new(1);
/// let lebesgue_r2 = ProductMeasure::new(mu, nu);
/// ```
#[derive(Clone)]
pub struct ProductMeasure<Σ1, Σ2, M1, M2, F1, F2, S1, S2, C1, C2>
where
    Σ1: SigmaAlgebra,
    Σ2: SigmaAlgebra,
    M1: Measure<Σ1, F1, S1, C1>,
    M2: Measure<Σ2, F2, S2, C2>,
    F1: MeasureProperty + 'static,
    F2: MeasureProperty + 'static,
    S1: MeasureProperty + 'static,
    S2: MeasureProperty + 'static,
    C1: MeasureProperty + 'static,
    C2: MeasureProperty + 'static,
{
    /// First measure
    measure1: M1,

    /// Second measure
    measure2: M2,

    /// Product σ-algebra
    product_sigma: ProductSigma<Σ1, Σ2>,

    /// Phantom type markers
    _phantom: PhantomData<(F1, F2, S1, S2, C1, C2)>,
}

impl<Σ1, Σ2, M1, M2, F1, F2, S1, S2, C1, C2> ProductMeasure<Σ1, Σ2, M1, M2, F1, F2, S1, S2, C1, C2>
where
    Σ1: SigmaAlgebra,
    Σ2: SigmaAlgebra,
    M1: Measure<Σ1, F1, S1, C1>,
    M2: Measure<Σ2, F2, S2, C2>,
    F1: MeasureProperty + 'static,
    F2: MeasureProperty + 'static,
    S1: MeasureProperty + 'static,
    S2: MeasureProperty + 'static,
    C1: MeasureProperty + 'static,
    C2: MeasureProperty + 'static,
{
    /// Create a new product measure
    ///
    /// # Arguments
    ///
    /// * `measure1` - First measure
    /// * `measure2` - Second measure
    /// * `product_sigma` - Product σ-algebra
    ///
    /// # Examples
    ///
    /// ```ignore
    /// use amari_measure::{ProductMeasure, ProductSigma, CountingMeasure};
    ///
    /// let mu = CountingMeasure::new();
    /// let nu = CountingMeasure::new();
    /// let sigma = ProductSigma::new(...);
    /// let product = ProductMeasure::new(mu, nu, sigma);
    /// // This gives counting measure on the product space
    /// ```
    pub fn new(measure1: M1, measure2: M2, product_sigma: ProductSigma<Σ1, Σ2>) -> Self {
        Self {
            measure1,
            measure2,
            product_sigma,
            _phantom: PhantomData,
        }
    }

    /// Get a reference to the first measure
    pub fn first_measure(&self) -> &M1 {
        &self.measure1
    }

    /// Get a reference to the second measure
    pub fn second_measure(&self) -> &M2 {
        &self.measure2
    }

    /// Get a reference to the product σ-algebra
    pub fn product_sigma(&self) -> &ProductSigma<Σ1, Σ2> {
        &self.product_sigma
    }
}

/// Fubini's theorem for computing double integrals
///
/// Given σ-finite measures μ on (X₁, Σ₁) and ν on (X₂, Σ₂), and an integrable
/// function f: X₁ × X₂ → ℝ, Fubini's theorem states:
///
/// ∫∫ f d(μ ⊗ ν) = ∫ (∫ f(x₁, x₂) dν(x₂)) dμ(x₁)
///               = ∫ (∫ f(x₁, x₂) dμ(x₁)) dν(x₂)
///
/// # Mathematical Foundation
///
/// ## Tonelli's Theorem (Non-negative functions)
///
/// If f ≥ 0 is measurable, the iterated integrals always exist (possibly infinite)
/// and equal the double integral.
///
/// ## Fubini's Theorem (Integrable functions)
///
/// If f is integrable with respect to μ ⊗ ν, then:
/// 1. For μ-a.e. x₁, the function x₂ ↦ f(x₁, x₂) is ν-integrable
/// 2. For ν-a.e. x₂, the function x₁ ↦ f(x₁, x₂) is μ-integrable
/// 3. The functions x₁ ↦ ∫ f(x₁, x₂) dν(x₂) and x₂ ↦ ∫ f(x₁, x₂) dμ(x₁) are integrable
/// 4. All three integrals are equal
///
/// # Type Parameters
///
/// This is a placeholder structure that will be fully implemented when
/// integrated with the integration module.
///
/// # Examples
///
/// ```ignore
/// use amari_measure::{fubini, LebesgueMeasure, ProductMeasure};
///
/// let mu = LebesgueMeasure::new(1);
/// let nu = LebesgueMeasure::new(1);
/// let product = ProductMeasure::new(mu, nu);
///
/// // Define f(x, y) = x * y on [0,1] × [0,1]
/// // ∫∫ xy dxdy = (∫ x dx)(∫ y dy) = (1/2)(1/2) = 1/4
/// // let result = fubini(&product, f);
/// ```
pub struct FubiniIntegrator<Σ1, Σ2, M1, M2, F1, F2, S1, S2, C1, C2>
where
    Σ1: SigmaAlgebra,
    Σ2: SigmaAlgebra,
    M1: Measure<Σ1, F1, S1, C1>,
    M2: Measure<Σ2, F2, S2, C2>,
    F1: MeasureProperty + 'static,
    F2: MeasureProperty + 'static,
    S1: MeasureProperty + 'static,
    S2: MeasureProperty + 'static,
    C1: MeasureProperty + 'static,
    C2: MeasureProperty + 'static,
{
    /// Product measure to integrate over
    product_measure: ProductMeasure<Σ1, Σ2, M1, M2, F1, F2, S1, S2, C1, C2>,
}

impl<Σ1, Σ2, M1, M2, F1, F2, S1, S2, C1, C2>
    FubiniIntegrator<Σ1, Σ2, M1, M2, F1, F2, S1, S2, C1, C2>
where
    Σ1: SigmaAlgebra,
    Σ2: SigmaAlgebra,
    M1: Measure<Σ1, F1, S1, C1>,
    M2: Measure<Σ2, F2, S2, C2>,
    F1: MeasureProperty + 'static,
    F2: MeasureProperty + 'static,
    S1: MeasureProperty + 'static,
    S2: MeasureProperty + 'static,
    C1: MeasureProperty + 'static,
    C2: MeasureProperty + 'static,
{
    /// Create a new Fubini integrator
    ///
    /// # Arguments
    ///
    /// * `product_measure` - The product measure to integrate over
    ///
    /// # Examples
    ///
    /// ```ignore
    /// use amari_measure::{FubiniIntegrator, ProductMeasure, LebesgueMeasure};
    ///
    /// let mu = LebesgueMeasure::new(1);
    /// let nu = LebesgueMeasure::new(1);
    /// let product = ProductMeasure::new(mu, nu);
    /// let integrator = FubiniIntegrator::new(product);
    /// ```
    pub fn new(product_measure: ProductMeasure<Σ1, Σ2, M1, M2, F1, F2, S1, S2, C1, C2>) -> Self {
        Self { product_measure }
    }

    /// Get a reference to the product measure
    pub fn product_measure(&self) -> &ProductMeasure<Σ1, Σ2, M1, M2, F1, F2, S1, S2, C1, C2> {
        &self.product_measure
    }
}

/// Convenience function for creating a Fubini integrator
///
/// # Arguments
///
/// * `product_measure` - The product measure to integrate over
///
/// # Examples
///
/// ```ignore
/// use amari_measure::{fubini, ProductMeasure, LebesgueMeasure};
///
/// let mu = LebesgueMeasure::new(1);
/// let nu = LebesgueMeasure::new(1);
/// let product = ProductMeasure::new(mu, nu);
///
/// let integrator = fubini(product);
/// // Use integrator to compute double integrals via iterated integrals
/// ```
pub fn fubini<Σ1, Σ2, M1, M2, F1, F2, S1, S2, C1, C2>(
    product_measure: ProductMeasure<Σ1, Σ2, M1, M2, F1, F2, S1, S2, C1, C2>,
) -> FubiniIntegrator<Σ1, Σ2, M1, M2, F1, F2, S1, S2, C1, C2>
where
    Σ1: SigmaAlgebra,
    Σ2: SigmaAlgebra,
    M1: Measure<Σ1, F1, S1, C1>,
    M2: Measure<Σ2, F2, S2, C2>,
    F1: MeasureProperty + 'static,
    F2: MeasureProperty + 'static,
    S1: MeasureProperty + 'static,
    S2: MeasureProperty + 'static,
    C1: MeasureProperty + 'static,
    C2: MeasureProperty + 'static,
{
    FubiniIntegrator::new(product_measure)
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::sigma_algebra::{BorelSigma, LebesgueSigma};

    #[test]
    fn test_product_sigma_creation() {
        let borel1 = BorelSigma::new(2);
        let borel2 = BorelSigma::new(3);
        let product = ProductSigma::new(borel1.clone(), borel2.clone());

        assert_eq!(product.first().dimension(), 2);
        assert_eq!(product.second().dimension(), 3);
    }

    #[test]
    fn test_product_sigma_with_lebesgue() {
        let lebesgue1 = LebesgueSigma::new(1);
        let lebesgue2 = LebesgueSigma::new(1);
        let product = ProductSigma::new(lebesgue1, lebesgue2);

        // ℝ × ℝ = ℝ²
        assert_eq!(product.first().dimension(), 1);
        assert_eq!(product.second().dimension(), 1);
    }

    #[test]
    fn test_product_sigma_different_dimensions() {
        // Test ℝ² × ℝ³ = ℝ⁵
        let sigma1 = BorelSigma::new(2);
        let sigma2 = BorelSigma::new(3);
        let product = ProductSigma::new(sigma1, sigma2);

        assert_eq!(product.first().dimension(), 2);
        assert_eq!(product.second().dimension(), 3);
        // Product space would be 5-dimensional
    }

    #[test]
    fn test_product_sigma_clone() {
        let borel1 = BorelSigma::new(1);
        let borel2 = BorelSigma::new(1);
        let product1 = ProductSigma::new(borel1, borel2);
        let product2 = product1.clone();

        assert_eq!(product1.first().dimension(), product2.first().dimension());
        assert_eq!(product1.second().dimension(), product2.second().dimension());
    }

    #[test]
    fn test_product_sigma_mixed_algebras() {
        // Test product of Borel and Lebesgue σ-algebras
        let borel = BorelSigma::new(2);
        let lebesgue = LebesgueSigma::new(3);
        let product = ProductSigma::new(borel, lebesgue);

        assert_eq!(product.first().dimension(), 2);
        assert_eq!(product.second().dimension(), 3);
    }

    #[test]
    fn test_product_sigma_zero_dimension() {
        // Test edge case with 0-dimensional spaces (points)
        let sigma1 = BorelSigma::new(0);
        let sigma2 = BorelSigma::new(1);
        let product = ProductSigma::new(sigma1, sigma2);

        assert_eq!(product.first().dimension(), 0);
        assert_eq!(product.second().dimension(), 1);
    }

    #[test]
    fn test_product_sigma_high_dimension() {
        // Test product resulting in high-dimensional space
        let sigma1 = BorelSigma::new(5);
        let sigma2 = BorelSigma::new(7);
        let product = ProductSigma::new(sigma1, sigma2);

        // ℝ⁵ × ℝ⁷ = ℝ¹²
        assert_eq!(product.first().dimension(), 5);
        assert_eq!(product.second().dimension(), 7);
    }

    #[test]
    fn test_product_sigma_symmetric() {
        // Test that ℝⁿ × ℝⁿ works correctly
        let sigma1 = LebesgueSigma::new(3);
        let sigma2 = LebesgueSigma::new(3);
        let product = ProductSigma::new(sigma1, sigma2);

        // ℝ³ × ℝ³ = ℝ⁶
        assert_eq!(product.first().dimension(), 3);
        assert_eq!(product.second().dimension(), 3);
    }

    #[test]
    fn test_product_sigma_accessor_consistency() {
        // Verify accessor methods return consistent results
        let borel1 = BorelSigma::new(2);
        let borel2 = BorelSigma::new(4);
        let product = ProductSigma::new(borel1.clone(), borel2.clone());

        assert_eq!(product.first().dimension(), borel1.dimension());
        assert_eq!(product.second().dimension(), borel2.dimension());
    }

    #[test]
    fn test_product_sigma_multiple_products() {
        // Test creating multiple distinct product σ-algebras
        let sigma1a = BorelSigma::new(1);
        let sigma1b = BorelSigma::new(2);
        let product1 = ProductSigma::new(sigma1a, sigma1b);

        let sigma2a = LebesgueSigma::new(3);
        let sigma2b = LebesgueSigma::new(4);
        let product2 = ProductSigma::new(sigma2a, sigma2b);

        // ℝ × ℝ² = ℝ³
        assert_eq!(product1.first().dimension(), 1);
        assert_eq!(product1.second().dimension(), 2);

        // ℝ³ × ℝ⁴ = ℝ⁷
        assert_eq!(product2.first().dimension(), 3);
        assert_eq!(product2.second().dimension(), 4);
    }

    #[test]
    fn test_product_sigma_equality() {
        // Test that two product σ-algebras with same dimensions are equal
        let borel1a = BorelSigma::new(2);
        let borel1b = BorelSigma::new(3);
        let product1 = ProductSigma::new(borel1a.clone(), borel1b.clone());

        let borel2a = BorelSigma::new(2);
        let borel2b = BorelSigma::new(3);
        let product2 = ProductSigma::new(borel2a, borel2b);

        // Same dimensions should give equal products
        assert_eq!(product1.first().dimension(), product2.first().dimension());
        assert_eq!(product1.second().dimension(), product2.second().dimension());
    }

    #[test]
    fn test_product_sigma_heterogeneous_types() {
        // Test that we can mix Borel and Lebesgue in both orders
        let borel = BorelSigma::new(2);
        let lebesgue = LebesgueSigma::new(3);

        // Borel × Lebesgue
        let product1 = ProductSigma::new(borel.clone(), lebesgue.clone());
        assert_eq!(product1.first().dimension(), 2);
        assert_eq!(product1.second().dimension(), 3);

        // Lebesgue × Borel
        let product2 = ProductSigma::new(lebesgue, borel);
        assert_eq!(product2.first().dimension(), 3);
        assert_eq!(product2.second().dimension(), 2);
    }
}
