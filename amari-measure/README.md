# amari-measure

Measure-theoretic foundations for geometric algebra - integration, probability measures, and analysis on multivector spaces.

## Overview

`amari-measure` provides measure theory, integration, and probability theory for multivector spaces in Clifford algebras. The crate bridges abstract measure theory with practical computation, featuring automatic differentiation, numerical integration, and type-safe convergence theorems.

## Features

- **σ-Algebras**: Borel, Lebesgue, power set, and trivial σ-algebras
- **Measures**: Counting, Dirac, Lebesgue, and probability measures
- **Geometric Measures**: Multivector-valued measures on Cl(p,q,r)
- **Radon-Nikodym Derivatives**: With automatic differentiation via dual numbers
- **Parametric Densities**: Gaussian, exponential, and custom families with autodiff
- **Numerical Integration**: Monte Carlo, Simpson, trapezoidal, adaptive quadrature
- **Fisher-Riemannian Geometry**: Statistical manifolds with Fisher information
- **Tropical Measures**: Max-plus algebra for extreme value statistics
- **Type-Safe Convergence**: Compile-time verification of theorem preconditions
- **Signed/Complex Measures**: Hahn and Jordan decompositions

## Installation

Add to your `Cargo.toml`:

```toml
[dependencies]
amari-measure = "0.12"
```

### Feature Flags

```toml
[dependencies]
# Default features
amari-measure = "0.12"

# With serialization
amari-measure = { version = "0.12", features = ["serde"] }

# With formal verification (Creusot)
amari-measure = { version = "0.12", features = ["formal-verification"] }
```

## Quick Start

### Parametric Densities with Automatic Differentiation

```rust
use amari_measure::parametric::families;

// Create a Gaussian density family
let gaussian = families::gaussian();

// Evaluate density and gradient at x=1.5, params=[μ=1.0, σ=2.0]
let (value, gradient) = gaussian.evaluate_with_gradient(1.5, &[1.0, 2.0]).unwrap();

// Compute Fisher information matrix from data
let data = vec![1.2, 1.5, 1.8];
let fisher = gaussian.fisher_information(&data, &[1.0, 2.0]).unwrap();
```

### Numerical Integration

```rust
use amari_measure::{monte_carlo_integrate, simpson_integrate};

// Monte Carlo integration of f(x) = x² over [0, 1]
let mc_result = monte_carlo_integrate(&|x| x * x, 0.0, 1.0, 10000).unwrap();
// Result ≈ 1/3

// Simpson's rule (higher accuracy)
let simpson_result = simpson_integrate(&|x| x * x, 0.0, 1.0, 100).unwrap();
```

### Geometric Measures on Multivector Spaces

```rust
use amari_measure::multivector_measure::GradeDecomposedMeasure;
use amari_core::Multivector;

// Create a 3D geometric measure (signature (3,0,0))
let measure = GradeDecomposedMeasure::<3, 0, 0>::new();

// Set from a multivector
let mv = Multivector::<3, 0, 0>::from_slice(&[1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0]);
let measure = GradeDecomposedMeasure::<3, 0, 0>::from_multivector(&mv);
```

## Mathematical Background

### σ-Algebras

A σ-algebra on a set X is a collection of subsets closed under:
- Complement
- Countable unions
- Countable intersections

```rust
use amari_measure::{BorelSigma, LebesgueSigma};

// Borel σ-algebra on ℝ (generated by open sets)
let borel = BorelSigma::<f64>::new();

// Lebesgue σ-algebra (completes Borel)
let lebesgue = LebesgueSigma::<f64>::new();
```

### Measures

A measure μ is a function from a σ-algebra to [0, ∞] satisfying:
- μ(∅) = 0
- Countable additivity

```rust
use amari_measure::{LebesgueMeasure, DiracMeasure, CountingMeasure};

// Lebesgue measure (length, area, volume)
let lebesgue = LebesgueMeasure::new();

// Dirac measure at point x₀
let dirac = DiracMeasure::at(3.14);

// Counting measure
let counting = CountingMeasure::new();
```

### Radon-Nikodym Derivatives

For absolutely continuous ν << μ, the Radon-Nikodym derivative dν/dμ exists:

```rust
use amari_measure::radon_nikodym_dual::DualRadonNikodym;

// Define a Gaussian density as Radon-Nikodym derivative
let rn = DualRadonNikodym::new(|x: f64, theta: f64| {
    let diff = x - theta;
    (-0.5 * diff * diff).exp()
});

// Compute score function: ∂/∂θ log p(x|θ)
let score = rn.score(1.0, 0.0).unwrap();

// Compute Fisher information from data
let data = vec![-1.0, 0.0, 1.0];
let fisher = rn.fisher_information(&data, 0.0).unwrap();
```

### Fisher-Riemannian Geometry

Statistical manifolds with Fisher information as the metric:

```rust
use amari_measure::fisher_measure::FisherMeasure;
use amari_measure::parametric::families;

// Create Fisher measure from Gaussian density
let gaussian = families::gaussian();
let fisher_measure = FisherMeasure::from_density(gaussian);

// Compute volume element at parameter point (for Jeffreys prior)
let params = vec![0.0, 1.0]; // μ=0, σ=1
let data = vec![-1.0, 0.0, 1.0];
let volume = fisher_measure.volume_element(&params, &data).unwrap();
```

### Tropical Measures

For extreme value statistics using max-plus algebra:

```rust
use amari_measure::tropical_measure::{MaxPlusMeasure, tropical_supremum_integrate};

// Create max-plus measure for finding suprema
let max_measure: MaxPlusMeasure = MaxPlusMeasure::new();

// Find supremum via tropical integration
let f = |x: f64| x * x;
let sample_points = vec![1.0, 2.0, 3.0, 4.0, 5.0];
let supremum = tropical_supremum_integrate(&f, &(), &sample_points).unwrap();
// supremum.value() == 25.0 (at x=5)
```

### Type-Safe Convergence Theorems

Compile-time verification of theorem preconditions:

```rust
use amari_measure::type_safe_convergence::{
    FunctionSequence, MonotoneIncreasing, NonNegative,
    apply_monotone_convergence_theorem
};

// Create a monotone increasing, non-negative sequence
let seq: FunctionSequence<f64, (MonotoneIncreasing, NonNegative)> =
    FunctionSequence::from_monotone_nonnegative_closures(vec![
        |x: f64| x,
        |x: f64| x + 1.0,
        |x: f64| x + 2.0,
    ]);

// Apply MCT - compiles because types are correct
let result = apply_monotone_convergence_theorem(&seq).unwrap();

// Would NOT compile with wrong property type:
// let wrong_seq: FunctionSequence<f64, NonNegative> = ...
// apply_monotone_convergence_theorem(&wrong_seq); // ❌ compile error
```

## Modules

| Module | Description |
|--------|-------------|
| `sigma_algebra` | σ-algebra implementations |
| `measure` | Basic measure types |
| `geometric_measure` | Multivector-valued measures |
| `multivector_measure` | Grade-decomposed measures |
| `integration` | Lebesgue integration |
| `density` | Densities and Radon-Nikodym |
| `radon_nikodym_dual` | Autodiff for Radon-Nikodym |
| `parametric` | Parametric density families |
| `fisher_measure` | Fisher-Riemannian geometry |
| `tropical_measure` | Max-plus extreme value measures |
| `numerical_integration` | Monte Carlo, Simpson, etc. |
| `type_safe_convergence` | Phantom type convergence theorems |
| `signed_measure` | Signed and complex measures |
| `product` | Product measures and Fubini's theorem |
| `convergence` | Convergence theorem implementations |
| `pushforward` | Pushforward and pullback of measures |

## Applications

### Statistical Inference

```rust
use amari_measure::parametric::families;
use amari_measure::fisher_measure::FisherMeasure;

// 1. Define parametric density family
let gaussian = families::gaussian();

// 2. Collect data
let data = vec![0.9, 1.1, 1.2, 0.8, 1.0];

// 3. Compute Fisher information (for Cramér-Rao bound)
let params = vec![1.0, 0.5]; // μ=1.0, σ=0.5
let fisher_info = gaussian.fisher_information(&data, &params).unwrap();

// 4. Create Fisher measure for geometric inference
let fisher_measure = FisherMeasure::from_density(gaussian);

// 5. Compute volume element (for Jeffreys prior)
let volume = fisher_measure.volume_element(&params, &data).unwrap();
```

### Machine Learning
- Natural gradient descent
- Variational inference
- KL divergence computation

### Physics
- Path integrals
- Partition functions
- Statistical mechanics

## Phantom Type System

The crate uses phantom types for compile-time verification:

```rust
use amari_measure::phantom::{Finite, SigmaFinite, Signed, Unsigned};

// Type parameters encode measure properties
// Compiler prevents invalid operations
```

## License

Licensed under either of Apache License, Version 2.0 or MIT License at your option.

## Part of Amari

This crate is part of the [Amari](https://github.com/justinelliottcobb/Amari) mathematical computing library.
