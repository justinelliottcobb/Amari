/**
 * Amari - High-performance Geometric Algebra library for TypeScript
 * 
 * This library provides TypeScript bindings for the Amari Rust crate,
 * enabling high-performance geometric algebra operations in web applications.
 */

// Import WASM bindings (will be generated by wasm-pack)
import init, {
  WasmMultivector,
  WasmRotor,
  BatchOperations
} from '../pkg/amari_wasm.js';

/**
 * Initialize the WASM module
 */
export async function initAmari(): Promise<void> {
  await init();
}

/**
 * Type-safe basis blade indices for 3D Clifford algebra
 */
export enum BasisBlade {
  Scalar = 0,     // 1
  E1 = 1,         // e1
  E2 = 2,         // e2
  E12 = 3,        // e1 ∧ e2
  E3 = 4,         // e3
  E13 = 5,        // e1 ∧ e3
  E23 = 6,        // e2 ∧ e3
  E123 = 7,       // e1 ∧ e2 ∧ e3 (pseudoscalar)
}

/**
 * Multivector in 3D Euclidean Clifford algebra Cl(3,0,0)
 */
export class Multivector {
  private inner: WasmMultivector;

  constructor(inner?: WasmMultivector) {
    this.inner = inner ?? new WasmMultivector();
  }

  /**
   * Create a zero multivector
   */
  static zero(): Multivector {
    return new Multivector();
  }

  /**
   * Create a scalar multivector
   */
  static scalar(value: number): Multivector {
    return new Multivector(WasmMultivector.scalar(value));
  }

  /**
   * Create from coefficient array
   */
  static fromCoefficients(coefficients: number[]): Multivector {
    if (coefficients.length !== 8) {
      throw new Error('3D Clifford algebra requires exactly 8 coefficients');
    }
    return new Multivector(WasmMultivector.fromCoefficients(new Float64Array(coefficients)));
  }

  /**
   * Create basis vector e1
   */
  static e1(): Multivector {
    return new Multivector(WasmMultivector.basisVector(0));
  }

  /**
   * Create basis vector e2
   */
  static e2(): Multivector {
    return new Multivector(WasmMultivector.basisVector(1));
  }

  /**
   * Create basis vector e3
   */
  static e3(): Multivector {
    return new Multivector(WasmMultivector.basisVector(2));
  }

  /**
   * Get all coefficients as array
   */
  getCoefficients(): number[] {
    return Array.from(this.inner.getCoefficients());
  }

  /**
   * Get coefficient for specific basis blade
   */
  getCoefficient(blade: BasisBlade | number): number {
    return this.inner.getCoefficient(blade);
  }

  /**
   * Set coefficient for specific basis blade
   */
  setCoefficient(blade: BasisBlade | number, value: number): this {
    this.inner.setCoefficient(blade, value);
    return this;
  }

  /**
   * Get scalar part
   */
  get scalar(): number {
    return this.getCoefficient(BasisBlade.Scalar);
  }

  /**
   * Get e1 component
   */
  get e1(): number {
    return this.getCoefficient(BasisBlade.E1);
  }

  /**
   * Get e2 component
   */
  get e2(): number {
    return this.getCoefficient(BasisBlade.E2);
  }

  /**
   * Get e3 component
   */
  get e3(): number {
    return this.getCoefficient(BasisBlade.E3);
  }

  /**
   * Get e12 component (bivector)
   */
  get e12(): number {
    return this.getCoefficient(BasisBlade.E12);
  }

  /**
   * Get e13 component (bivector)
   */
  get e13(): number {
    return this.getCoefficient(BasisBlade.E13);
  }

  /**
   * Get e23 component (bivector)
   */
  get e23(): number {
    return this.getCoefficient(BasisBlade.E23);
  }

  /**
   * Get e123 component (pseudoscalar)
   */
  get e123(): number {
    return this.getCoefficient(BasisBlade.E123);
  }

  /**
   * Geometric product (fundamental GA operation)
   */
  geometricProduct(other: Multivector): Multivector {
    return new Multivector(this.inner.geometricProduct(other.inner));
  }

  /**
   * Inner product (dot product for vectors)
   */
  innerProduct(other: Multivector): Multivector {
    return new Multivector(this.inner.innerProduct(other.inner));
  }

  /**
   * Outer product (wedge product)
   */
  outerProduct(other: Multivector): Multivector {
    return new Multivector(this.inner.outerProduct(other.inner));
  }

  /**
   * Scalar product (grade-0 part of geometric product)
   */
  scalarProduct(other: Multivector): number {
    return this.inner.scalarProduct(other.inner);
  }

  /**
   * Reverse (conjugate)
   */
  reverse(): Multivector {
    return new Multivector(this.inner.reverse());
  }

  /**
   * Grade projection
   */
  gradeProjection(grade: number): Multivector {
    return new Multivector(this.inner.gradeProjection(grade));
  }

  /**
   * Exponential (creates rotors from bivectors)
   */
  exp(): Multivector {
    return new Multivector(this.inner.exp());
  }

  /**
   * Compute norm
   */
  norm(): number {
    return this.inner.norm();
  }

  /**
   * Normalize to unit multivector
   */
  normalize(): Multivector {
    return new Multivector(this.inner.normalize());
  }

  /**
   * Compute multiplicative inverse
   */
  inverse(): Multivector {
    return new Multivector(this.inner.inverse());
  }

  /**
   * Addition
   */
  add(other: Multivector): Multivector {
    return new Multivector(this.inner.add(other.inner));
  }

  /**
   * Subtraction
   */
  sub(other: Multivector): Multivector {
    return new Multivector(this.inner.sub(other.inner));
  }

  /**
   * Scalar multiplication
   */
  scale(scalar: number): Multivector {
    return new Multivector(this.inner.scale(scalar));
  }

  /**
   * Convert to string representation
   */
  toString(): string {
    const coeffs = this.getCoefficients();
    const terms: string[] = [];

    if (Math.abs(coeffs[0]) > 1e-10) terms.push(`${coeffs[0].toFixed(3)}`);
    if (Math.abs(coeffs[1]) > 1e-10) terms.push(`${coeffs[1].toFixed(3)}e1`);
    if (Math.abs(coeffs[2]) > 1e-10) terms.push(`${coeffs[2].toFixed(3)}e2`);
    if (Math.abs(coeffs[3]) > 1e-10) terms.push(`${coeffs[3].toFixed(3)}e12`);
    if (Math.abs(coeffs[4]) > 1e-10) terms.push(`${coeffs[4].toFixed(3)}e3`);
    if (Math.abs(coeffs[5]) > 1e-10) terms.push(`${coeffs[5].toFixed(3)}e13`);
    if (Math.abs(coeffs[6]) > 1e-10) terms.push(`${coeffs[6].toFixed(3)}e23`);
    if (Math.abs(coeffs[7]) > 1e-10) terms.push(`${coeffs[7].toFixed(3)}e123`);

    return terms.length > 0 ? terms.join(' + ') : '0';
  }
}

/**
 * Rotor for efficient rotations
 */
export class Rotor {
  private inner: WasmRotor;

  constructor(inner: WasmRotor) {
    this.inner = inner;
  }

  /**
   * Create rotor from bivector and angle
   */
  static fromBivector(bivector: Multivector, angle: number): Rotor {
    return new Rotor(WasmRotor.fromBivector(bivector.inner, angle));
  }

  /**
   * Create rotor for rotation around axis
   */
  static fromAxisAngle(axis: Multivector, angle: number): Rotor {
    // Normalize the axis
    const normalizedAxis = axis.normalize();
    
    // Create bivector from dual of axis (in 3D, this is just the axis vector)
    const bivector = normalizedAxis.scale(0.5); // Half-angle for rotor
    
    return Rotor.fromBivector(bivector, angle);
  }

  /**
   * Apply rotor to transform a multivector
   */
  apply(mv: Multivector): Multivector {
    return new Multivector(this.inner.apply(mv.inner));
  }

  /**
   * Compose with another rotor
   */
  compose(other: Rotor): Rotor {
    return new Rotor(this.inner.compose(other.inner));
  }

  /**
   * Get inverse rotor
   */
  inverse(): Rotor {
    return new Rotor(this.inner.inverse());
  }
}

/**
 * Builder pattern for constructing multivectors
 */
export class MultivectorBuilder {
  private coefficients: number[] = new Array(8).fill(0);

  /**
   * Set scalar component
   */
  scalar(value: number): this {
    this.coefficients[BasisBlade.Scalar] = value;
    return this;
  }

  /**
   * Set e1 component
   */
  e1(value: number): this {
    this.coefficients[BasisBlade.E1] = value;
    return this;
  }

  /**
   * Set e2 component
   */
  e2(value: number): this {
    this.coefficients[BasisBlade.E2] = value;
    return this;
  }

  /**
   * Set e3 component
   */
  e3(value: number): this {
    this.coefficients[BasisBlade.E3] = value;
    return this;
  }

  /**
   * Set e12 component
   */
  e12(value: number): this {
    this.coefficients[BasisBlade.E12] = value;
    return this;
  }

  /**
   * Set e13 component
   */
  e13(value: number): this {
    this.coefficients[BasisBlade.E13] = value;
    return this;
  }

  /**
   * Set e23 component
   */
  e23(value: number): this {
    this.coefficients[BasisBlade.E23] = value;
    return this;
  }

  /**
   * Set e123 component (pseudoscalar)
   */
  e123(value: number): this {
    this.coefficients[BasisBlade.E123] = value;
    return this;
  }

  /**
   * Build the multivector
   */
  build(): Multivector {
    return Multivector.fromCoefficients(this.coefficients);
  }
}

/**
 * Batch operations for performance
 */
export class BatchOps {
  /**
   * Batch geometric product
   */
  static async geometricProduct(a: Float64Array, b: Float64Array): Promise<Float64Array> {
    const result = await BatchOperations.batchGeometricProduct(a, b);
    return new Float64Array(result);
  }

  /**
   * Batch addition
   */
  static async add(a: Float64Array, b: Float64Array): Promise<Float64Array> {
    const result = await BatchOperations.batchAdd(a, b);
    return new Float64Array(result);
  }
}

// Convenience exports for common operations
export const GA = {
  scalar: Multivector.scalar,
  e1: Multivector.e1,
  e2: Multivector.e2,
  e3: Multivector.e3,
  zero: Multivector.zero,
  builder: () => new MultivectorBuilder(),
};

// Export all classes and enums
export {
  initAmari as init,
  Multivector,
  Rotor,
  MultivectorBuilder,
  BatchOps,
  BasisBlade,
};